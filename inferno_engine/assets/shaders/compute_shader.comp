#version 440

// struct Sphere {
//     vec3 center;
//     float radius;
//     vec3 color;
// };

layout(local_size_x = 8, local_size_y = 8) in;
layout(rgba32f, binding = 0) writeonly uniform image2D img_output;

uniform float u_width;
uniform float u_height;

uniform vec3 camera_position;
uniform vec3 camera_up;
uniform vec3 camera_forward;
uniform float fov_y;

uniform vec3 sphere_center;
uniform float sphere_radius;
uniform vec3 sphere_color;

//uniform Sphere spheres[2];

void main() {
    // base pixel colour for image
    vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);
    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    float aspect_ratio = u_width / u_height;
    float x = (2.0 * (float(pixel_coords.x) + 0.5) / float(u_width) - 1.0) * aspect_ratio * tan(fov_y / 2.0);
    float y = (1.0 - 2.0 * (float(pixel_coords.y) + 0.5) / float(u_height)) * tan(fov_y / 2.0);
    vec3 ray_direction = normalize(camera_forward + x * normalize(cross(camera_up, camera_forward)) + y * camera_up);

    //
    // interesting stuff happens here later
    //

    // Trace ray against spheres
    vec3 color = vec3(0.0);
    float t_min = 1e20;

    vec3 oc = camera_position - sphere_center;
    float a = dot(ray_direction, ray_direction);
    float b = 2.0 * dot(oc, ray_direction);
    float c = dot(oc, oc) - sphere_radius * sphere_radius;
    float discriminant = b * b - 4.0 * a * c;
    if (discriminant >= 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0.0 && t < t_min) {
            t_min = t;
            vec3 hit_point = camera_position + t * ray_direction;
            vec3 normal = normalize(hit_point - sphere_center);
            color = sphere_color * max(dot(normal, -ray_direction), 0.0);
            pixel = vec4(color, 1.0);
        }
    }

    // output to a specific pixel in the image
    imageStore(img_output, pixel_coords, pixel);
}