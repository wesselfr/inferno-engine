#version 440

struct Voxel
{
    vec4 pos;
    vec4 color;
};

layout(local_size_x = 8, local_size_y = 8) in;
layout(rgba32f, binding = 0) writeonly uniform image2D img_output;

layout(std430, binding = 1) buffer Voxels {
    Voxel voxels[];
};
uniform uint num_voxels;

uniform float u_width;
uniform float u_height;

uniform vec3 camera_position;
uniform vec3 camera_up;
uniform vec3 camera_forward;
uniform float fov_y;

uniform vec3 clear_color;

uniform vec3 voxel_center;
uniform float voxel_size;
uniform vec3 voxel_color;

struct Ray {
    vec3 origin;
    vec3 direction;
};

bool intersect_voxel(Ray ray, vec3 position, out vec3 normal, out float distance) {
    vec3 bounds_min = position - (voxel_size * 0.5);
    vec3 bounds_max = position + (voxel_size * 0.5);
    vec3 inv_direction = 1.0 / ray.direction;
    vec3 t0s = (bounds_min - ray.origin) * inv_direction;
    vec3 t1s = (bounds_max - ray.origin) * inv_direction;
    vec3 tmins = min(t0s, t1s);
    vec3 tmaxs = max(t0s, t1s);
    float tmin = max(max(tmins.x, tmins.y), tmins.z);
    float tmax = min(min(tmaxs.x, tmaxs.y), tmaxs.z);
    if (tmin > tmax) {
        return false;
    }
    vec3 hit_point = ray.origin + ray.direction * tmin;
    vec3 normal_voxel = vec3(0.0);
    if (abs(hit_point.x - position.x) < 0.0001) {
        normal_voxel += vec3(1.0, 0.0, 0.0);
    } else if (abs(hit_point.x - (position.x + 1.0)) < 0.0001) {
        normal_voxel += vec3(-1.0, 0.0, 0.0);
    }
    if (abs(hit_point.y - position.y) < 0.0001) {
        normal_voxel += vec3(        0.0, 1.0, 0.0);
    } else if (abs(hit_point.y - (position.y + 1.0)) < 0.0001) {
        normal_voxel += vec3(0.0, -1.0, 0.0);
    }
    if (abs(hit_point.z - position.z) < 0.0001) {
        normal_voxel += vec3(0.0, 0.0, 1.0);
    } else if (abs(hit_point.z - (position.z + 1.0)) < 0.0001) {
        normal_voxel += vec3(0.0, 0.0, -1.0);
    }
    normal = normalize(normal_voxel);
    distance = tmin;
    return true;
}

void main() {
    // base pixel colour for image
    vec4 pixel = vec4(clear_color, 1.0);
    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    float aspect_ratio = u_width / u_height;
    float x = (2.0 * (float(pixel_coords.x) + 0.5) / float(u_width) - 1.0) * aspect_ratio * tan(fov_y / 2.0);
    float y = (1.0 - 2.0 * (float(pixel_coords.y) + 0.5) / float(u_height)) * tan(fov_y / 2.0);
    vec3 ray_direction = normalize(camera_forward + x * normalize(cross(camera_up, camera_forward)) + y * camera_up);
    Ray ray = Ray(camera_position, ray_direction);
    //
    // interesting stuff happens here later
    //

    // Trace ray against spheres
    vec3 color = vec3(0.0);
    vec3 normal;
    float distance;
    float last_distance = 9999999;

    for(int i = 0; i < 10; i++){
        vec3 voxel_pos = voxels[i].pos.xyz;
        if(intersect_voxel(ray, voxel_pos, normal, distance))
        {
            if(distance<last_distance){
                last_distance = distance;
                pixel = voxels[i].color;
                imageStore(img_output, pixel_coords, pixel);
            }
        }
    }
    // output to a specific pixel in the image
    imageStore(img_output, pixel_coords, pixel);
}